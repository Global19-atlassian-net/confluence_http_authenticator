#
# Configuration file for the Confluence RemoteUserAuthenticator
#

# Whether to create user accounts for new users
# Acceptable values: true, false

create.users=true


# Whether existing accounts should have their name and
# email address updated upon login 
# Acceptable values: true, false

update.info=true

# Whether new and existing accounts should have their last login date
# and previous login date updated in user properties upon login 
# Acceptable values: true, false
#
# This property will only be obeyed when you are not using ShibLoginFilter.
update.last.login.date=true


# Whether the configuration file should be automatically reloadded when it's changed.
reload.config=false

# When reloading the configuration file, how long to wait (in milliseconds) between
# checking the configuration file for changes?
reload.config.check.interval=5000


# The default group(s) to for newly created users, only used if create.users is true.
#
# Notes:
# * Group name list can be comma or semicolon delimited.
# * Currently groups must pre-exist.

default.roles=confluence-users


# HTTP header names where the user's full name and email address will come from.
# The full name and email address headers need not be populated.

header.fullname = CONF_FULL_NAME
header.email = CONF_EMAIL


# Indication whether the group memberships of the user should be updated after creation.
# (acceptable values: true/false). If true, then group memberships will be added
# (default.roles, and header.dynamicroles depending on the mapping headers)
# whenever the user authenticates, and not just if the user is created by the
# authenticator.

update.roles=true


# Indication whether HTTP header values should be converted to UTF-8 to avoid an issue
# noted by Helsinki University: "where there is something not using utf-8 involved,
# 16-bit characters get bytes 83 c2 inserted between." 

# OPTIONAL
#convert.to.utf8=true


# OPTIONAL
# This feature takes effect only when update.roles is true.
#
# List of dynamicroles headers, along side with the labels of their group-mapper.
# Each header can have a set of mapper labels to be activated.
# A header entry without appropriate assigned label will be ignored
#
# e.g. say we'd like to perform automatic group provisioning based on
# headers: "SHIB-EP-ENTITLEMENT", "affiliation", and our defined "fix-role-header"
# (note these have to match whatever defined in AAP),
# then we can define the following:
#
#dynamicroles.header.SHIB-EP-ENTITLEMENT = label1, label2, label4, label3
#dynamicroles.header.affiliation = label1, label5
#dynamicroles.header.fix-role-header = pass


# Should the dynamicroles attempt to automatically create the role
# in confluence if such role does not exist?
#
#dynamicroles.auto_create_role = false


# Instruct to convert all output groups into lowercase
# before creating them on confluence. This is necessary to overcome
# confluence's limitation of disallowing group names in upper case
# (though there is discussion to rectify this from confluence team)
# Default value to true
#dynamicroles.output.tolowercase = true

# Define mapper label and its logic for dynamicroles. Each mapper has to define either
# "match" or "transform" property, otherwise it will not be included in the
# dynamicroles processing.
#
# Notes:
# * Colons need to be escaped by \
# * Attribute names are case-insensitive.
# * Value list can be comma or semicolon delimited.
#
# Description of each property:
# * match = java regex string to match against the ENTIRE input, you can use java
#           regex groupings (http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html#cg)
#           e.g. to explicitly match a fix string: match= Hello World
#                to match with grouping: match = some\:urn\:(\\w+):(.*)
#
# * casesensitive = boolean, whether the match regex should care about case
#                   sensitivity matching, default to true
#
# * transform = a fix string replacement of the input (e.g. the group or groups).
#               when not specified, it will simply takes the input value.
#               transform can be a list of groups separated by comma or semicolon e.g.
#               transform= A, B, C which means if this mapper matches, the output
#               would be group A, B, and C. You can also use $1..$N to represent
#               a matched regex group (as done by "match" regex). $0 refers to
#               the entire input string.
#               e.g. spit out a fix output: transform = Hello There
#                    reuse some regex grouping: transform = confluence-$1, confluence-$2
#                    (suppose the input is "some:urn:users:administrators", then
#                     using the last example match regex we are converting
#                     this to "confluence-users" and "confluence-administrators"
#
# example:
# map "some:urn:group1:group2" to groups called "group1" and "group2"
#dynamicroles.mapper.label1.match=some\:urn\:(\\w+)\:(.*)
#dynamicroles.mapper.label1.transform=$1, $2
#
# map "StaFF" to "cs100"
#dynamicroles.mapper.map2.match = staff
#dynamicroles.mapper.map2.casesensitive = false
#dynamicroles.mapper.map2.transform = cs100
#

# OPTIONAL
# Normally, users added to a group based on Shibboleth attributes would stay in
# the group forever, even if they no longer have the attribute.  The
# purge.roles feature allows to specify a list of groups which should be
# automatically purged of any users who no longer have the attributes to regain
# entry (comma or semicolon separated).
# When loggin in, a user will be automatically removed from the group IFF the
# user would not be added to the group (either via dynamicroles.header or
# default.roles).  This feature takes effect only when update.roles is true.
#
# Example:
# remove members from role starting with "alum", "alumni",
# or any other "alum*", as well as from cs101. (ignore case sensitivity).
#
#purge.roles = alum(\\w*) , cs101

